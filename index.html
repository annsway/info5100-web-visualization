<html>
    <style>
        #container{
            width: 800px;
            height: 500px;
            background: black;
            margin: 0 auto;
        }
        #barchart_category{
            width: 800px;
            height: 500px;
            background: black;
            margin: 0 auto;
            position: relative;
        }
        #my_dataviz{
            width: 800px;
            height: 500px;
            background: black;
            margin: 0 auto;
        }
        #timeseries{
            width: 800px;
            height: 500px;
            background: black;
            margin: 0 auto;
        }
        #piechart{
            width: 800px;
            height: 500px;
            background: black;
            margin: 0 auto;
        }
        #barchart_div{
            width: 800px;
            height: 500px;
            background: black;
            margin: 0 auto;
            position: relative;
        }
        .svg_barchart_category{
            margin: 10px 70px;
        }
        svg{
            margin: 10px 150px;
        }
        .timeseries{
            margin: 10px 150px;
        }
        .barchart{
            margin: 10px 150px;
        }

        .axis path,
        .axis line {
        fill: none;
        stroke: white;
        shape-rendering: crispEdges;
        }
    
        .axis text {
        font-family: 'Microsoft YaHei';
        font-size: 12px;
        color: white;
        }
        .myrect{
            fill: lightgoldenrodyellow;
        }
        .gridlines line {
            stroke: #fff;
        }
        .gridlines .domain{
            stroke: none;
        }
    </style>
    <body style="background-color: black; font-family: Courier New, Courier, monospace;">
        <head><script src="https://d3js.org/d3.v7.min.js"></script></head>
        <div id="top-header" style="color:#fff; font-size: 20pt;"> 5100 Project 1 - Tianchen Wang; Yun Zhou; Zhi Lin</div>
        <h1 style="color:#fff; text-align: center;"> Exploration of YELP Data</h1>
        <div id="barchart_category" style="margin-bottom: 100;">
            <h2 style="color:#fff; text-align: center;">Top Ten Business Categories</h2>
            <h3 style="color:#fff;text-align: center;">Count of Business Units Per Categories</h3>
        </div>
        <div id = "barchart_div" style="margin-top: 300;">
            <h2 style="color:#fff; text-align: center;">How many business units are still opened/closed?</h2>
            <h3 style="color:#fff;text-align: center;">Count of Opened/Closed Business Units Per State</h3>
            <svg id="barchart" height="600" width="600" ></svg>
        </div>
        
        <div id="my_dataviz" style="color:#fff; font-size: 11pt;margin-top: 100;">
            <h2 style="color:#fff; text-align: center;">Which City Has The Largest Review Number</h2>
            <h3 style="color:#fff;text-align: center;">Count of review per City</h3>
        </div>
        <div id = "timeseries" style="margin-top: 200;">
            <h2 style="color:#fff; text-align: center;">Does the Covid Affects the Offline Life?</h2>
            <h3 style="color:#fff;text-align: center;">Review Count Over Time</h3>
            <svg id="timeseries" height="400" width="800">
            </svg>
        </div>

        <div id="piechart">
            <h2 style="color:#fff;text-align: center;">Most People Leave ... 5 Star!</h2>
            <h3 style="color:#fff;text-align: center;">Count of Different Star Rate</h3>
        </div>
        <script>
    // Which City Has The Largest Review Number
     d3.json('./yelp_business_10percent.json').then( 
            (data) => {
                console.log(data)
                var string = ""
                var obj =[]
                for (var i = 0; i < data.length; i++) {
                    string = data[i].city
                    number = data[i].review_count
                    obj.push({
                        name:string,
                        value: number
                    });
                }
                console.log(obj)
                var holder = {};

                obj.forEach(function(d) {
                if (holder.hasOwnProperty(d.name)) {
                    holder[d.name] = holder[d.name] + d.value;
                } else {
                    holder[d.name] = d.value;
                }
                });
                var obj2 = [];
                for (var prop in holder) {
                obj2.push({ name: prop, value: holder[prop] });
                }
                var items = []
                for (var i = 0; i < obj2.length; i++) {
                    items.push([obj2[i].name, obj2[i].value])
                }
                items.sort(function(first, second) {
                return second[1] - first[1];
                });
                console.log(items)

                var top_1 = items[0]
                var name_1 = top_1[0]
                var num_1 = top_1[1]

                var top_2 = items[1]
                var name_2 = top_2[0]
                var num_2 = top_2[1]

                var top_3 = items[2]
                var name_3 = top_3[0]
                var num_3 = top_3[1]

                var top_4 = items[3]
                var name_4 = top_4[0]
                var num_4 = top_4[1]

                var top_5 = items[4]
                var name_5 = top_5[0]
                var num_5 = top_5[1]

                var top_6 = items[5]
                var name_6 = top_6[0]
                var num_6 = top_6[1]

                var top_7 = items[6]
                var name_7 = top_7[0]
                var num_7 = top_7[1]

                var top_8 = items[7]
                var name_8 = top_8[0]
                var num_8 = top_8[1]

                var top_9 = items[8]
                var name_9 = top_9[0]
                var num_9 = top_9[1]

                var top_10 = items[9]
                var name_10 = top_10[0]
                var num_10 = top_10[1]

                let datas=[
                    {
                        Country:name_1,
                        Value:num_1
                    },
                    {
                        Country:name_2,
                        Value:num_2
                    },
                    {
                        Country:name_3,
                        Value:num_3
                    },
                    {
                        Country:name_4,
                        Value:num_4
                    },
                    {
                        Country:name_5,
                        Value:num_5
                    },
                    {
                        Country:name_6,
                        Value:num_6
                    },
                    {
                        Country:name_7,
                        Value:num_7
                    },
                    {
                        Country:name_8,
                        Value:num_8
                    },
                    {
                        Country:name_9,
                        Value:num_9
                    },
                    {
                        Country:name_10,
                        Value:num_10
                    }
                ]
                console.log(datas)
                const margin = {top: 0, right: 0, bottom: 0, left: 0},
                    width = 500 - margin.left - margin.right,
                    height = 580 - margin.top - margin.bottom,
                    innerRadius = 90,
                    outerRadius = Math.min(width, height) / 2;
    
                const svg = d3.select("#my_dataviz")
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${width/2+margin.left}, ${height/2+margin.top})`); 
                const x = d3.scaleBand()
                    .range([0, 2 * Math.PI])
                    .align(0)
                    .domain(datas.map(d => d.Country));
                const y = d3.scaleRadial()
                    .range([innerRadius, outerRadius])
                    .domain([0, 180000]); 
                svg.append("g")
                    .selectAll("path")
                    .data(datas)
                    .join("path")
                    .attr("fill", "pink")
                    .attr("d", d3.arc() 
                        .innerRadius(innerRadius)
                        .outerRadius(d => y(d['Value']))
                        .startAngle(d => x(d.Country))
                        .endAngle(d => x(d.Country) + x.bandwidth())
                        .padAngle(0.01)
                        .padRadius(innerRadius))
                
                svg.append("g")
                        .attr("class", "svg")
                    .selectAll("g")
                    .data(datas)
                    .join("g")
                        .attr("text-anchor", function(d) { return (x(d.Country) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "end" : "start"; })
                        .attr("transform", function(d) { return "rotate(" + ((x(d.Country) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")"+"translate(" + (y(d['Value'])+10) + ",0)"; })
                    .append("text")
                        .text(function(d){return(d.Country)})
                        .attr("transform", function(d) { return (x(d.Country) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "rotate(180)" : "rotate(0)"; })
                        .attr("alignment-baseline", "middle")
                        .style("fill", "white")
                
                });

                // Timeseries plot
                const svg_timeseries = d3.select("svg#timeseries");
                const width = svg_timeseries.attr("width");
                const height = svg_timeseries.attr("height");
                const margin = {top: 10, right: 10, bottom: 50, left: 50};
                const chartWidth = width - margin.left - margin.right;
                const chartHeight = height - margin.top - margin.bottom;

                let annotations = svg_timeseries.append("g").attr("id","annotations");
                let chartArea_timeseries = svg_timeseries.append("g").attr("id","points")
                                .attr("transform",`translate(${margin.left},${margin.top})`);
                 d3.json('yelp_review_time_1percent.json').then( 
                (data2) => {
                    let array = []
                    for (var i = 0; i < data2.length; i++) {
                        data2[i].date = data2[i].date.substring(0,10)
                        array.push(data2[i].date)
                }
                console.log(array)
                const count2 = {};
                for (const element of array) {
                    if (count2[element]) {
                        count2[element] += 1;
                    } else {
                        count2[element] = 1;
                    }
                }
                
                data = []
                for (const [key, value] of Object.entries(count2)) {
                    data.push({
                        date:key,
                        value: value
                    });
                }
                console.log(data)                   
                
                let timeParser = d3.timeParse('%Y-%m-%d');
                let colorScale = d3.scaleOrdinal(d3.schemeCategory10);
                data.forEach( d => {
                    d['date'] = timeParser(d["date"]);
                });
                const dateExtent = d3.extent(data, d => d['date']);
                const dateScale = d3.scaleTime().domain(dateExtent).range([0,chartWidth-10]);
                let bottomAxis = d3.axisBottom(dateScale)
                let bottomGridlines = d3.axisBottom(dateScale)
                                        .tickSize(-chartHeight-10)
                                        .tickFormat("")
                annotations.append("g")
                    .attr("class", "x axis")
                    .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                    .call(bottomAxis);
                annotations.append("g")
                    .attr("class", "x gridlines")
                    .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                    .call(bottomGridlines);
                
                const carbonExtent = d3.extent(data, d => d['value']);
                const carbonScale = d3.scaleLinear().domain(carbonExtent).range([chartHeight, 0]);
                let leftAxis = d3.axisLeft(carbonScale)
                let leftGridlines = d3.axisLeft(carbonScale)
                                        .tickSize(-chartWidth-10)
                                        .tickFormat("")
                annotations.append("g")
                    .attr("class", "y axis")
                    .attr("transform",`translate(${margin.left},${margin.top})`)
                    .call(leftAxis)
                annotations.append("g")
                    .attr("class", "y gridlines")
                    .attr("transform",`translate(${margin.left},${margin.top})`)
                    .call(leftGridlines);
                
                var lineGen = d3.line()
                                .x( data => dateScale(data['date']) )
                                .y( data => carbonScale(data['value']) )
                                .curve(d3.curveMonotoneX); 
                svg_timeseries.append("text")
                    .attr("class", "x label")
                    .attr("text-anchor", "end")
                    .attr("x", width -100)
                    .attr("y", height - 6)
                    .style("fill", "white")
                    .text("Review Time");
                svg_timeseries.append("text")
                    .attr("class", "y label")
                    .attr("text-anchor", "end")
                    .attr("y", 8)
                    .attr("dy", ".100em")
                    .attr("transform", "rotate(-90)")
                    .style("fill", "white")
                    .text("Review Count");
                chartArea_timeseries.selectAll("circle").data(data)
                        .join("circle")
                        .attr("r", 3)
                        .attr('opacity', 0.9)
                        .attr("fill", "skyblue")   // using attr here, style would work too
                        .attr("cx", d => dateScale(d['date']) )
                        .attr("cy", d => carbonScale(d['value']) );
                                        
            });
                // pie chart
                d3.json('./yelp_review_star_2percent.json').then( 
                    (data2) => {
                        function getCount(star_num) {
                            var count = 0;
                            for (var i = 0; i < data2.length; i++) {
                                if (data2[i].stars == star_num) {
                                count++;
                            }
                            }
                            return count;
                        }
                var star_1_pie = getCount(1)
                var star_2_pie = getCount(2)
                var star_3_pie = getCount(3)
                var star_4_pie = getCount(4)
                var star_5_pie = getCount(5)

                var data_pie =
                {1: star_1_pie,2: star_2_pie,3: star_3_pie,4: star_4_pie,5: star_5_pie} 

                const width = 450,
                    height = 450,
                    margin = 40;

                const radius = Math.min(width, height) / 2 - margin

                const svg = d3.select("#piechart")
                .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                .append("g")
                    .attr("transform", `translate(${width / 2}, ${height / 2})`);

                const color = d3.scaleOrdinal()
                .range(d3.schemeSet2);

                const pie = d3.pie()
                .value(function(d) {return d[1]})
                const data_ready = pie(Object.entries(data_pie))

                const arcGenerator = d3.arc()
                .innerRadius(0)
                .outerRadius(radius)

                svg
                .selectAll('mySlices')
                .data(data_ready)
                .join('path')
                    .attr('d', arcGenerator)
                    .attr('fill', function(d){ return(color(d.data[0])) })
                    .attr("stroke", "white")
                    .style("stroke-width", "2px")
                    .style("opacity", 0.9)

                svg
                .selectAll('mySlices')
                .data(data_ready)
                .join('text')
                .text(function(d){ return "Star" + d.data[0]})
                .attr("transform", function(d) { return `translate(${arcGenerator.centroid(d)})`})
                .style("text-anchor", "middle")
                .style("font-size", 15)
                    })
                // barchart


            d3.json("yelp_business_10percent.json")
                .then((data) => {
                    let svg_barchart = d3.select("svg#barchart");
                    const width = svg_barchart.attr("width");
                    const height = svg_barchart.attr("height");
                    const margin = { top: 5, right: 10, bottom: 10, left: 50 };
                    const chartWidth = width - margin.left - margin.right;
                    const chartHeight = height - margin.top - margin.bottom;
                    let operations = {}
                    for (let i = 0; i < data.length; i++) {
                        let state = data[i].state;
                        if (!(state in operations)) {
                            operations[state] = { 'is_open': 0, 'is_closed': 0 };
                        }
                        if (data[i].is_open == 1) {
                            operations[state].is_open += 1;
                        }
                        if (data[i].is_open == 0) {
                            operations[state].is_closed += 1;
                        }
                    }
                    let json = []
                    for (const [key, value] of Object.entries(operations)) {
                        if(value.is_open > 10 || value.is_closed > 10) {
                        let dict = { "state": key, "is_open": value.is_open, "is_closed": value.is_closed }
                        json.push(dict);
                        }
                    }

                    console.log(json);

                    let maxValue = d3.max(json, d => Math.max(d.is_open, d.is_closed));

                    let padding = 5

                    let xScale = d3.scaleBand()
                        .domain(json.map(data => data.state))
                        .range([padding, chartWidth - 2 * padding])
                        .padding(0.5)

                    let openScale = d3.scaleLinear()
                        .domain([0, maxValue + 10])
                        .range([0, chartHeight / 2.0 -30]);

                    let closedScale = d3.scaleLinear()
                        .domain([0, maxValue + 10])
                        .range([0, chartHeight / 2.0]);


                    // C. create axis labels and gridlines
                    // x axis
                    let bottomAxis = d3.axisBottom(xScale)
                    axis_position = chartHeight -200
                    svg_barchart.append('g')
                        .attr('class', 'axis')
                        .attr('transform', 'translate(0,' + axis_position + ')')
                        .call(bottomAxis)
                        .selectAll("text")
                        .style("text-anchor", "end")
                        .attr("dx", "-1em")
                        .attr("dy", "-1em")
                        .attr("transform", "rotate(-90)");

                    json.forEach((d, i) => {
                        svg_barchart.append('g')
                            .append("line")
                            .attr("x1", xScale(d['state']))
                            .attr("x2", xScale(d['state']))
                            .attr("y1", chartHeight / 2)
                            .attr("y2", chartHeight / 2 - openScale(d['is_open']))
                            .style("stroke", "skyblue")
                            .style("stroke-width", 10)
                            ;
                    });

                    json.forEach((d, i) => {
                        svg_barchart.append('g')
                            .append("line")
                            .attr("x1", xScale(d['state']))
                            .attr("x2", xScale(d['state']))
                            .attr("y1", chartHeight / 2)
                            .attr("y2", chartHeight / 2 + closedScale(d['is_closed']))
                            .style("stroke", "orange")
                            .style("stroke-width", 10);
                    });


                });

// barchart_categorey
d3.json('yelp_business_10percent.json').then(
            (data) => {
                var string = ""
                for (var i = 0; i < data.length; i++) {
                    string = data[i].categories  + ", " +string
                }
                var categories_list = string.split(',');
                //console.log(categories_list)
                const count = {};
                for (const element of categories_list) {
                    if (count[element]) {
                        count[element] += 1;
                    } else {
                        count[element] = 1;
                    }
                }
                // Create items array
                var items = Object.keys(count).map(function(key) {
                return [key, count[key]];
                });
                // Sort the array based on the second element
                items.sort(function(first, second) {
                return second[1] - first[1];
                });
                // Create a new array with only the first 5 items

                var top_1 = items[0]
                var name_1 = top_1[0]
                var num_1 = top_1[1]

                var top_2 = items[1]
                var name_2 = top_2[0]
                var num_2 = top_2[1]

                var top_3 = items[2]
                var name_3 = top_3[0]
                var num_3 = top_3[1]

                var top_4 = items[3]
                var name_4 = top_4[0]
                var num_4 = top_4[1]

                var top_5 = items[4]
                var name_5 = top_5[0]
                var num_5 = top_5[1]

                var top_6 = items[5]
                var name_6 = top_6[0]
                var num_6 = top_6[1]

                var top_7 = items[6]
                var name_7 = top_7[0]
                var num_7 = top_7[1]

                var top_8 = items[7]
                var name_8 = top_8[0]
                var num_8 = top_8[1]

                var top_9 = items[8]
                var name_9 = top_9[0]
                var num_9 = top_9[1]

                var top_10 = items[9]
                var name_10 = top_10[0]
                var num_10 = top_10[1]

                 let datas=[
        {
            key:name_1,
            value:num_1
        },
        {
            key:name_2,
            value:num_2
        },
        {
            key:name_3,
            value:num_3
        },
        {
            key:name_4,
            value:num_4
        },
        {
            key:name_5,
            value:num_5
        },
        {
            key:name_6,
            value:num_6
        },
        {
            key:name_7,
            value:num_7
        },
        {
            key:name_8,
            value:num_8
        },
        {
            key:name_9,
            value:num_9
        },
        {
            key:name_10,
            value:num_10
        }
    ]
    let width=800,height=600,padding=75

    let svg=d3.select("#barchart_category")
    .append("svg")
    .attr("width",width)
    .attr("height",height)
    .attr("class", "svg_barchart_category")

    let xScale=d3.scaleBand()
    .domain(datas.map(d=>d.key))
    .range([padding,width-2*padding])
    .padding(0.5)

    let yScale=d3.scaleLinear()
    .domain([0,d3.max(datas,(d)=>d.value)])
    .range([height-padding*2,0])

    let xAxis=d3.axisBottom(xScale)
    let yAxis=d3.axisLeft(yScale)

    const bartext = svg.append('g')
      .attr('id', 'bartext');

    svg.append('g')
      .attr('class', 'axis')
      .attr('transform', 'translate(0,'+(height-padding)+')')
      .call(xAxis)
      .selectAll("text")
        .style("text-anchor", "end")
        .attr("dx", "-.8em")
        .attr("dy", ".15em")
        .attr("transform", "rotate(-45)");

    svg.append('g')
      .attr('class', 'axis')
      .attr('transform', 'translate('+ padding+','+padding+')')
      .call(yAxis);

    var myColor = d3.scaleOrdinal()
      .domain(datas)
      .range(d3.schemeAccent);

    let rects = svg.selectAll("rect")
      .data(datas)

    rects.enter()
    .append("rect")
    .attr("x",d=>xScale(d.key))
    .attr("y",d=>yScale(d.value)+padding)
    .attr("width",xScale.bandwidth())
    .attr("height",d=>height-padding*2-yScale(d.value))
    .attr("fill", d=>"pink")
    .attr("fill", d=>myColor(d.value))
    .transition()   // Smooth append transition
        .duration(1000)
        .attr('y', d => yScale(d.value)+padding)
        .attr('height', d => height-padding*2-yScale(d.value))
        .on('end', function () {    // Animation when a bar is selected
          d3.select(this).on('mouseenter', function (event, actual, i) {
            d3.selectAll('.times')
              .attr('opacity', 0)
            d3.select(this)
              .transition()
              .duration(300)
              .attr('opacity', 0.6)
              .attr('x', d => xScale(d.key))
              .attr('width', xScale.bandwidth())
            const y = yScale(actual.value)
            let line = svg.append('line')
              .attr('id', 'limit')
              .attr('x1', 0)
              .attr('y1', y+padding)
              .attr('x2', width-150)
              .attr('y2', y+padding)
              .attr('stroke', 'grey')
              .style('stroke-dasharray', ("3","3"))
          })
          .on('mouseleave', function () {
            d3.selectAll('.times')
              .attr('opacity', 1)
            d3.select(this)
              .transition()
              .duration(300)
              .attr('opacity', 1)
              .attr('x', d => xScale(d.key))
              .attr('width', xScale.bandwidth())
            svg.selectAll('#limit').remove()
          })
        rects.exit().remove()
        bartext2.exit().remove()
    })

    let bartext2 = bartext.selectAll("text")
      .data(datas);

    bartext2
      .attr('x', d => xScale(d.key) + 10)
      .attr('y', d=> yScale(d.key) + padding- 5)
      .attr('text-anchor', 'middle')
      .text((d) => `${d.value}`)

    bartext2
      .enter()
      .append('text')
      .attr('class', 'text_value')
      .attr('x', d => xScale(d.key) + 10)
      .attr('y', d => yScale(d.value) + padding- 5)
      .attr('text-anchor', 'middle')
      .text(d => `${d.value}`)
      .attr('opacity', 0)
      .transition()
      .delay(300)
      .attr('opacity', 1)
      .style("fill", "white")
    })
            </script>
    </body>
</html>
